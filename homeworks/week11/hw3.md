## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

### 湊雜與加密的差別
兩者雖然有相同的功能：幫使用者的密碼變成亂數排列，但他們根本的差別在：「加密可逆推回到原本的密碼，雜湊不能還原」。
#### 雜湊（Hash）：多對一關係，沒辦法從結果回推原本的密碼

* 如果使用者密碼輸入為：aaa，透過雜湊的函式，輸出值為：5u8fed7，由於雜湊的演算機制，我們無法將雜輸出值解回原本的輸入值。
* 若是發生「不同的密碼輸入」卻產生「相同的雜湊值」這樣的狀況，成為碰撞（collision)。不過，目前現存又知名的雜湊演算法，要發生碰撞的機率非常低。
* 常見的雜湊演算法：SHA-256、MD5（已被證實不安全）、SHA-1（已被證實不安全）。

#### 加密（Encryption）
明文密碼經加密後會產生密文與金鑰（Key），透過金鑰，可逆推回去原本的明文密碼。

### 為什麼密碼要雜湊過後才存入資料庫
使用者的密碼會透過網站的後端資料庫設定，儲存會員的資料。若是遇到駭客入侵或是網站管理者的壞心，盜取資料之後，會員的密碼若沒有經雜湊處理，將會造成很大的資安風險。為了防止資料庫外洩、不讓密碼輕易被盜取，造成使用者更多的傷害，網站的 IT 團隊會運用雜湊的演算機制，將原本的密碼加以變化之後才存入資料庫。

我們都有過類似的經驗，當登入網站時，如果忘記密碼，按下「忘記密碼」的按鈕，網站都會請你重設密碼，而不是將原本的密碼透過電子郵件或簡訊回覆提供。這也是因為在資料庫存入的是雜湊過後的密碼，而不是原本使用者存入的明文密碼。所以若是有網站傳回明文密碼的話，就要小心其中隱藏的資安風險。


## `include`、`require`、`include_once`、`require_once` 的差別

* `require`：引入檔案，如果 `require()`  中的檔案不存在（或是路徑錯誤），程式就不會繼續往下跑，並且丟出錯誤訊息。

* `include`：引入檔案，如果 ```include()```  中的檔案不存在（或是路徑錯誤），程式不會中止，仍然會繼續執行後面的程式碼。

* `require_once`：同```require()```，但會去檢查目前的檔案是否已經引入過，如果有，就不會再去打開檔案重新引入，如果沒有才會去執行引入。

*  `include_once`：同`require_once()`的功能，避免檔案重複引入的問題。
與`require_once()`之間的差異，如同`require()`和`include()`之間的差異一樣，`include_once()` ，如果檔案不存在（或是路徑錯誤），也不會停止程式的執行。

參考資料：[PHP：require V.S. include](http://code-beginner.logdown.com/posts/389687-phprequire-vs-include)

## 請說明 SQL Injection 的攻擊原理以及防範方法

### 攻擊原理：駭客的填字遊戲
駭客在各種能輸入 SQL 程式碼的地方，用一些惡意字串竄改 SQL 語法，導致資料庫被攻入。

### 防範方法：Prepare Statement
透過 Prepare Statement 的機制，幫我們預防針對 SQL  語法的攻擊。將欲輸入的參數都改成問號，再透過`bind_param()`替換參數，再去執行 SQL query  語法拿取資料。


##  請說明 XSS 的攻擊原理以及防範方法

### 攻擊原理：在別人網站，執行 JavaScript
在 HTML 裡使用```<script>```的標籤，撰寫 JavaScript 程式碼，可以讓網頁有更好的互動跟動態效果；但如果有人惡意在你的網站寫入任何 JavaScript 程式碼，就會產生竄改網頁、導入釣魚網站竊取資料的疑慮。

### 防範方法：PHP 跳脫字元內建函式-`htmlspecialchars()`
透過`htmlspecialchars()`將輸出的內容轉譯成純文字，而非程式碼。建議在資料輸出之前在進行編碼；存進資料庫的內容，還是以明文儲存，避免之後資料在跨平台使用時（例如：ios、android 等平台系統），原始資料不至於讓人無法解讀。

## 請說明 CSRF 的攻擊原理以及防範方法

### 攻擊原理
CSRF 是駭客在其他網頁塞入一個「目標 domain」的連結，讓使用者不知情狀況下，針對目標網站發出 request，運用瀏覽器會自動帶入該網站的 cookie 的漏洞進行攻擊，而網站因為通常是依靠 cookie 而進行身分認定，因此駭客可以將網址讓其他使用者有意或著是無意間的觸發該網址，進而達成仿造他人身分操作網站。

### 防範方法
能成立 CSRF 的攻擊，是因為瀏覽器的機制所導致的，因此目前在瀏覽器端的防禦最為推薦的方法是：SameSite cookie。設置了 SameSite cookie 的機制之後，只要瀏覽器驗證判斷不是在同一個 site  底下發出的 request，都不會帶上這個 cookie，透過雙層驗證的方式，讓資訊安全更為完善。

參考資料：[讓我們來談談 CSRF](https://blog.techbridge.cc/2017/02/25/csrf-introduction/)